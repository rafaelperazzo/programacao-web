# -*- coding: utf-8 -*-
from __future__ import division
import math

#Dados iniciais:
A=1
c=1
r=1
a=40000
E=30000000
e = input('digite o valor de e %f:')
L = input('digite o valor de L %f:')
Pcr = (((math.pi)**2)*E*A)/((L/r)**2)
Po = Pcr/2 

#Execução do programa:
x= (L/(2*r))*math.sqrt((Po/(E*A)))
def sec(x):
    sec= (1/math.cos(x))
    return sec
f = (Po/A) - (a/(1+((e*c)/(r**2))*sec(x)))
x= (L/(2*r))*math.sqrt((Po/(E*A)))
z = (a*c*e*L)*math.tan(x)*sec(x)
y=4*(r**3)*E*A*math.sqrt(Po/(E*A))*((1+(((e*c)/(r**2))*sec(x)))**2)
derf= (z/y) +(1/A)
cont = 0
erro=999
while(erro>0.4):  
    Ps=Po
    x = (L/(2*r))*math.sqrt((Po/(E*A)))
    z = (a*c*e*L)*math.tan(x)*sec(x)
    y=4*(r**3)*E*A*math.sqrt(Po/(E*A))*((1+(((e*c)/(r**2))*sec(x)))**2)    
    FPo= (Po/A) - (a/(1+((e*c)/(r**2))*sec(x)))
    FlinhaPo= (z/y) +(1/A)     
    Pomais1= (Po - (FPo/FlinhaPo))
    erro= math.fabs(Pomais1 - Po)      
    Po=Pomais1
    cont = cont +1
    if Po>Pcr:
        Po = (Ps+Pcr)/2
    print ('O valor do erro é: %f' %erro)
    print ('O valor de Po é: %f' %Po)
print ('O número de iterações é: %d' %cont)